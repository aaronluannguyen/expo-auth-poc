# Architecture Deep Dive

This document provides an in-depth technical explanation of the authentication architecture, design patterns, and implementation details.

## Table of Contents

- [System Architecture](#system-architecture)
- [Authentication Flow Details](#authentication-flow-details)
- [State Management](#state-management)
- [Security Architecture](#security-architecture)
- [Data Flow](#data-flow)
- [Design Patterns](#design-patterns)
- [Performance Optimizations](#performance-optimizations)
- [Error Handling Strategy](#error-handling-strategy)

---

## System Architecture

### Layered Architecture

The application follows a layered architecture pattern with clear separation of concerns:

```
┌─────────────────────────────────────────────────────────┐
│                   Presentation Layer                     │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐     │
│  │   Screens   │  │ Components  │  │  Navigation │     │
│  └─────────────┘  └─────────────┘  └─────────────┘     │
└─────────────────────────────────────────────────────────┘
                          │
                          ↓
┌─────────────────────────────────────────────────────────┐
│                     Hook Layer                           │
│  ┌─────────────────────────────────────────────┐        │
│  │  useAuth, useIsAuthenticated, useCurrentUser │        │
│  └─────────────────────────────────────────────┘        │
└─────────────────────────────────────────────────────────┘
                          │
                          ↓
┌─────────────────────────────────────────────────────────┐
│                  State Management Layer                  │
│  ┌─────────────────────────────────────────────┐        │
│  │         AuthContext + AuthProvider          │        │
│  │  - Global auth state                        │        │
│  │  - State transitions                        │        │
│  │  - Side effects management                  │        │
│  └─────────────────────────────────────────────┘        │
└─────────────────────────────────────────────────────────┘
                          │
                          ↓
┌─────────────────────────────────────────────────────────┐
│                    Business Logic Layer                  │
│  ┌──────────────────┐  ┌──────────────────┐            │
│  │   authService    │  │  tokenStorage    │            │
│  │  - OAuth flow    │  │  - Encryption    │            │
│  │  - Token mgmt    │  │  - Persistence   │            │
│  │  - API calls     │  │  - Expiration    │            │
│  └──────────────────┘  └──────────────────┘            │
└─────────────────────────────────────────────────────────┘
                          │
                          ↓
┌─────────────────────────────────────────────────────────┐
│                   Infrastructure Layer                   │
│  ┌──────────────────┐  ┌──────────────────┐            │
│  │  expo-auth-      │  │ expo-secure-     │            │
│  │  session         │  │ store            │            │
│  │  (OAuth client)  │  │ (iOS Keychain/   │            │
│  │                  │  │  Android KeyStore)│            │
│  └──────────────────┘  └──────────────────┘            │
└─────────────────────────────────────────────────────────┘
                          │
                          ↓
┌─────────────────────────────────────────────────────────┐
│                     External Services                    │
│  ┌──────────────────────────────────────────────┐       │
│  │          WorkOS Authentication API           │       │
│  │  - Authorization endpoint                    │       │
│  │  - Token endpoint                            │       │
│  │  - UserInfo endpoint                         │       │
│  └──────────────────────────────────────────────┘       │
└─────────────────────────────────────────────────────────┘
```

### Separation of Concerns

Each layer has a specific responsibility:

1. **Presentation Layer**: UI rendering and user interaction
2. **Hook Layer**: Simplified interface to state management
3. **State Management**: Global auth state and coordination
4. **Business Logic**: Core authentication logic
5. **Infrastructure**: Platform-specific implementations
6. **External Services**: Third-party APIs

---

## Authentication Flow Details

### OAuth 2.0 with PKCE - Step by Step

#### Step 1: PKCE Code Verifier Generation

```typescript
// Generated by expo-auth-session
function generateCodeVerifier(): string {
  // Generate 128 random bytes
  const randomBytes = crypto.getRandomValues(new Uint8Array(128));

  // Convert to base64url (URL-safe base64)
  // [A-Z][a-z][0-9]-_~ with no padding
  const base64url = btoa(String.fromCharCode(...randomBytes))
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=/g, '');

  return base64url;
}
```

**Result**: Random string like `dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk`

#### Step 2: Code Challenge Creation

```typescript
async function deriveCodeChallenge(verifier: string): Promise<string> {
  // 1. Convert verifier to byte array
  const encoder = new TextEncoder();
  const data = encoder.encode(verifier);

  // 2. Hash with SHA-256
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);

  // 3. Convert to base64url
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const base64url = btoa(String.fromCharCode(...hashArray))
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=/g, '');

  return base64url;
}
```

**Result**: SHA-256 hash like `E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM`

#### Step 3: Authorization Request

```
GET https://api.workos.com/sso/authorize?
  response_type=code
  &client_id=client_01XXXX
  &redirect_uri=myapp://oauth/callback
  &scope=openid+profile+email
  &code_challenge=E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM
  &code_challenge_method=S256
  &state=xyzABC123                # CSRF protection (recommended)
```

**What happens**:
1. User's browser opens this URL
2. WorkOS shows login page
3. User authenticates with their IdP (Google, Microsoft, etc.)
4. WorkOS validates user
5. Redirects back to app

#### Step 4: Authorization Response

```
myapp://oauth/callback?
  code=AUTH_CODE_HERE
  &state=xyzABC123
```

**Security Check**: Verify `state` matches what we sent (prevents CSRF)

#### Step 5: Token Exchange

```http
POST https://api.workos.com/sso/token
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code
&client_id=client_01XXXX
&code=AUTH_CODE_HERE
&code_verifier=dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk
&redirect_uri=myapp://oauth/callback
```

**Security**: WorkOS verifies:
```
SHA256(code_verifier) == code_challenge (from step 3)
```

If they match, tokens are issued. If not, request is rejected.

**Response**:
```json
{
  "access_token": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refresh_token": "v1.MRnJ4T5pXFYM...",
  "id_token": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "Bearer",
  "expires_in": 3600
}
```

#### Step 6: Token Storage

Tokens are immediately encrypted and stored:

```typescript
// iOS: Keychain
Keychain.setGenericPassword({
  service: 'com.myapp.auth',
  account: 'access_token',
  password: tokens.accessToken,
  accessible: Keychain.ACCESSIBLE.WHEN_UNLOCKED
});

// Android: EncryptedSharedPreferences
val masterKey = MasterKey.Builder(context)
  .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
  .build()

val encryptedPrefs = EncryptedSharedPreferences.create(
  context,
  "auth_tokens",
  masterKey,
  EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
  EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
)

encryptedPrefs.edit()
  .putString("access_token", tokens.accessToken)
  .apply()
```

### Token Refresh Flow

```typescript
// Triggered when token expires or is about to expire

async function refreshAccessToken(refreshToken: string): Promise<AuthTokens> {
  // 1. POST to token endpoint
  const response = await fetch('https://api.workos.com/sso/token', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({
      grant_type: 'refresh_token',
      client_id: CLIENT_ID,
      refresh_token: refreshToken,
    }),
  });

  // 2. Parse response
  const data = await response.json();

  // 3. Update stored tokens
  const newTokens = {
    accessToken: data.access_token,
    refreshToken: data.refresh_token || refreshToken,  // Some providers rotate refresh tokens
    expiresIn: data.expires_in,
    tokenType: data.token_type,
  };

  // 4. Store new tokens (overwrites old ones)
  await storeTokens(newTokens);

  return newTokens;
}
```

**When refresh fails**:
- Refresh token is invalid/expired
- User's session was revoked
- Network error (retry-able)

**Action**: Force user to re-authenticate

---

## State Management

### AuthContext Implementation

#### State Shape

```typescript
interface AuthState {
  user: User | null;              // Current user or null
  tokens: AuthTokens | null;      // Current tokens or null
  isLoading: boolean;             // Loading indicator
  isAuthenticated: boolean;       // Computed: user !== null
  error: string | null;           // Error message or null
}
```

#### State Transitions

```
┌─────────────────┐
│   INITIAL       │
│ loading: true   │
│ user: null      │
└────────┬────────┘
         │
         │ Session restore attempt
         │
    ┌────▼─────┬──────────────┐
    │          │              │
    │ Success  │ Failed       │ No session
    │          │              │
┌───▼──────┐ ┌─▼──────────┐ ┌▼─────────────┐
│AUTHENTICATED│UNAUTHENTICATED│UNAUTHENTICATED│
│loading:false││loading:false ││loading:false │
│user: User   ││user: null    ││user: null    │
│error: null  ││error: msg    ││error: null   │
└─────┬───────┘└──────────────┘└──────────────┘
      │
      │ Logout / Token expired
      │
┌─────▼──────────┐
│UNAUTHENTICATED │
│loading: false  │
│user: null      │
└────────────────┘
```

#### State Management Pattern

Using **Reducer Pattern** with React hooks:

```typescript
// State updates are batched and predictable
setAuthState((prevState) => ({
  ...prevState,
  user: newUser,
  isAuthenticated: true,
  isLoading: false,
}));

// Alternative: Could use useReducer for complex state
const [state, dispatch] = useReducer(authReducer, initialState);

dispatch({ type: 'AUTH_SUCCESS', payload: { user, tokens } });
dispatch({ type: 'AUTH_FAILURE', payload: { error } });
dispatch({ type: 'AUTH_LOGOUT' });
```

### Why Context API vs Redux?

**Context API Advantages**:
- ✅ Built-in, no dependencies
- ✅ Simpler for single state domain
- ✅ Less boilerplate
- ✅ Sufficient for auth state (doesn't change frequently)

**When to use Redux**:
- Multiple complex state domains
- Frequent state updates
- Need middleware (sagas, thunks)
- Time-travel debugging
- Shared state across many components

**Performance Consideration**:
```typescript
// AuthContext only re-renders when auth state changes
// This happens infrequently:
// - On app start (session restore)
// - On login (once)
// - On logout (once)
// - On token refresh (every ~1 hour)
```

---

## Security Architecture

### Defense in Depth

Multiple layers of security:

```
┌──────────────────────────────────────────────────────┐
│ Layer 1: OAuth 2.0 + PKCE                            │
│ - No client secret in app                            │
│ - Code interception protected                        │
└──────────────────────────────────────────────────────┘
                     ↓
┌──────────────────────────────────────────────────────┐
│ Layer 2: Encrypted Token Storage                     │
│ - iOS: Keychain (hardware-backed)                    │
│ - Android: EncryptedSharedPreferences + KeyStore     │
└──────────────────────────────────────────────────────┘
                     ↓
┌──────────────────────────────────────────────────────┐
│ Layer 3: Token Expiration                            │
│ - Short-lived access tokens (1 hour)                 │
│ - Automatic refresh                                  │
│ - Proactive refresh before expiration                │
└──────────────────────────────────────────────────────┘
                     ↓
┌──────────────────────────────────────────────────────┐
│ Layer 4: HTTPS Only                                  │
│ - All API calls over TLS 1.2+                        │
│ - Certificate validation                             │
└──────────────────────────────────────────────────────┘
                     ↓
┌──────────────────────────────────────────────────────┐
│ Layer 5: App Security                                │
│ - No logging of sensitive data                       │
│ - Environment variables for config                   │
│ - Secure coding practices                            │
└──────────────────────────────────────────────────────┘
```

### Token Security Analysis

#### Access Token

**Properties**:
- **Format**: JWT (JSON Web Token)
- **Lifetime**: 1 hour (typical)
- **Scope**: Limited to requested permissions
- **Revocable**: Yes (by auth server)

**Structure**:
```
eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.    ← Header
eyJzdWIiOiJ1c2VyXzAxWFhYWCIsImV4cCI6...  ← Payload
SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_...    ← Signature
```

**Payload example**:
```json
{
  "sub": "user_01XXXXXX",           // Subject (user ID)
  "iss": "https://api.workos.com",  // Issuer
  "aud": "client_01XXXXXX",         // Audience (your app)
  "exp": 1638360000,                // Expiration timestamp
  "iat": 1638356400,                // Issued at
  "scope": "openid profile email"   // Granted scopes
}
```

**Security Features**:
- Signed with RS256 (RSA + SHA-256)
- Can't be forged without private key
- Self-contained (no DB lookup needed)
- Expires automatically

#### Refresh Token

**Properties**:
- **Format**: Opaque string (not JWT)
- **Lifetime**: 30-90 days (typical)
- **Single-use**: Some providers rotate on each use
- **Revocable**: Yes

**Security Features**:
- Stored in database (can be revoked)
- Only valid for token endpoint
- Can't be used for API calls
- Detects stolen tokens (rotation)

**Rotation Example**:
```
User requests token refresh with refresh_token_A
↓
Server issues new access_token + refresh_token_B
↓
Server invalidates refresh_token_A
↓
If refresh_token_A used again → Security breach detected
↓
Server revokes entire session
```

#### ID Token (OpenID Connect)

**Properties**:
- **Format**: JWT
- **Lifetime**: Same as access token
- **Purpose**: User identity info
- **Usage**: Display user info, don't use for API auth

**Payload example**:
```json
{
  "sub": "user_01XXXXXX",
  "email": "user@example.com",
  "email_verified": true,
  "given_name": "John",
  "family_name": "Doe",
  "picture": "https://...",
  "organization_id": "org_01XXXXXX"
}
```

### Storage Security Details

#### iOS Keychain

```
┌────────────────────────────────────────┐
│          Your App (Sandbox)            │
│  ┌──────────────────────────────┐      │
│  │   expo-secure-store API      │      │
│  └───────────┬──────────────────┘      │
└──────────────┼─────────────────────────┘
               │
               ↓
┌──────────────────────────────────────────┐
│            iOS Keychain                   │
│  ┌────────────────────────────────┐      │
│  │  Encrypted with device key     │      │
│  │  (derived from passcode)       │      │
│  └────────────────────────────────┘      │
└───────────────┬──────────────────────────┘
                │
                ↓ (iPhone 5s+)
┌───────────────────────────────────────────┐
│         Secure Enclave (Hardware)         │
│  • Crypto operations                      │
│  • Key storage                            │
│  • Isolated from main processor           │
└───────────────────────────────────────────┘
```

**Security Properties**:
- Encrypted at rest
- Tied to device passcode
- Survives app uninstall (optional)
- Protected by biometrics (Touch ID/Face ID)
- Secure Enclave on modern devices

#### Android KeyStore

```
┌────────────────────────────────────────┐
│          Your App (Sandbox)            │
│  ┌──────────────────────────────┐      │
│  │   expo-secure-store API      │      │
│  └───────────┬──────────────────┘      │
└──────────────┼─────────────────────────┘
               │
               ↓
┌──────────────────────────────────────────┐
│    EncryptedSharedPreferences            │
│  ┌────────────────────────────────┐      │
│  │  • Data encrypted with AES-256 │      │
│  │  • Keys encrypted with AES-256 │      │
│  └────────────┬───────────────────┘      │
└─────────────────┼────────────────────────┘
                  │
                  ↓
┌─────────────────────────────────────────────┐
│         Android KeyStore System             │
│  • Master key stored here                   │
│  • Hardware-backed (modern devices)         │
│  • Isolated from apps                       │
└─────────────────────────────────────────────┘
```

**Security Properties**:
- AES-256-GCM encryption
- Keys in hardware (modern Android)
- Protected by screen lock
- Survives app uninstall (optional)

---

## Data Flow

### Component → Hook → Context → Service

```typescript
// 1. Component uses hook
function LoginScreen() {
  const { login, isLoading, error } = useAuth();

  return (
    <Button onPress={login}>Login</Button>
  );
}

// 2. Hook accesses context
function useAuth() {
  return useContext(AuthContext);
}

// 3. Context calls service
const AuthProvider = ({ children }) => {
  const login = async () => {
    const { user, tokens } = await loginWithWorkOS();  // Service call
    setAuthState({ user, tokens, isAuthenticated: true });
  };

  return (
    <AuthContext.Provider value={{ login, ... }}>
      {children}
    </AuthContext.Provider>
  );
};

// 4. Service performs logic
async function loginWithWorkOS() {
  const authResult = await promptAsync(authRequest);
  const tokens = await exchangeCodeForTokens(authResult.code);
  await storeTokens(tokens);
  const user = await fetchUserInfo(tokens.accessToken);
  return { user, tokens };
}
```

### Data Flow Diagram

```
User Taps Login
       ↓
 LoginScreen.tsx
   onPress={login}
       ↓
 useAuth() hook
   returns login function
       ↓
 AuthContext.tsx
   login() method
       ↓
 authService.ts
   loginWithWorkOS()
       ↓
 expo-auth-session
   promptAsync()
       ↓
 Device Browser
   User authenticates
       ↓
 OAuth Callback
   Redirect with code
       ↓
 authService.ts
   exchangeCodeForTokens()
       ↓
 WorkOS API
   POST /token
       ↓
 tokenStorage.ts
   storeTokens()
       ↓
 expo-secure-store
   Encrypt & save
       ↓
 authService.ts
   fetchUserInfo()
       ↓
 WorkOS API
   GET /userinfo
       ↓
 AuthContext.tsx
   setAuthState()
       ↓
 RootNavigator.tsx
   Observes isAuthenticated
       ↓
 HomeScreen.tsx
   Rendered to user
```

---

## Design Patterns

### 1. Provider Pattern (Context API)

**Purpose**: Share auth state globally without prop drilling

```typescript
// Provider wraps app
<AuthProvider>
  <App />
</AuthProvider>

// Any child component can access
function AnyComponent() {
  const { user } = useAuth();
  return <Text>{user.name}</Text>;
}
```

### 2. Hook Pattern (Custom Hooks)

**Purpose**: Encapsulate reusable logic

```typescript
// Hook abstracts context usage
function useAuth() {
  const context = useContext(AuthContext);
  if (!context) throw new Error('useAuth must be used within AuthProvider');
  return context;
}

// Clean component code
function MyComponent() {
  const { user, login } = useAuth();  // Simple!
}
```

### 3. Service Layer Pattern

**Purpose**: Separate business logic from UI

```typescript
// Services are pure functions
export async function loginWithWorkOS(): Promise<{ user, tokens }> {
  // Complex OAuth logic here
}

// Context orchestrates services
const login = async () => {
  const result = await loginWithWorkOS();  // Service call
  setAuthState(result);  // State update
};
```

### 4. Error Boundary Pattern

**Purpose**: Graceful error handling

```typescript
class AuthError extends Error {
  type: AuthErrorType;
  constructor(type, message, originalError) {
    super(message);
    this.type = type;
    this.originalError = originalError;
  }
}

// Typed errors allow specific handling
try {
  await login();
} catch (error) {
  if (error instanceof AuthError) {
    switch (error.type) {
      case AuthErrorType.NETWORK_ERROR:
        showMessage('Check your connection');
        break;
      case AuthErrorType.USER_CANCELLED:
        // Silent
        break;
      default:
        showMessage('Login failed');
    }
  }
}
```

### 5. Facade Pattern (expo-auth-session)

**Purpose**: Simplify complex OAuth flow

```typescript
// Without facade (manual OAuth):
// - Generate code verifier
// - Create code challenge
// - Build authorization URL
// - Open browser
// - Listen for redirect
// - Parse response
// - Handle errors

// With facade (expo-auth-session):
const [request, response, promptAsync] = useAuthRequest({
  clientId: CLIENT_ID,
  redirectUri: REDIRECT_URI,
  usePKCE: true,  // Handles PKCE automatically!
});

await promptAsync();  // Handles everything!
```

---

## Performance Optimizations

### 1. Memoization

```typescript
// Prevent unnecessary re-renders
const authContextValue = useMemo(() => ({
  user,
  tokens,
  isAuthenticated,
  isLoading,
  error,
  login,
  logout,
}), [user, tokens, isAuthenticated, isLoading, error]);

return (
  <AuthContext.Provider value={authContextValue}>
    {children}
  </AuthContext.Provider>
);
```

### 2. Lazy Loading

```typescript
// Screens loaded only when needed
const ProfileScreen = lazy(() => import('./screens/ProfileScreen'));

// Navigation handles code splitting
<Stack.Screen name="Profile" component={ProfileScreen} />
```

### 3. Token Pre-fetching

```typescript
// Refresh token before it expires
const REFRESH_BUFFER = 300;  // 5 minutes

if (expiresIn <= REFRESH_BUFFER) {
  // User won't notice, happens in background
  await refreshAccessToken();
}
```

### 4. Parallel Operations

```typescript
// Store all tokens in parallel
await Promise.all([
  SecureStore.setItemAsync('access_token', tokens.accessToken),
  SecureStore.setItemAsync('refresh_token', tokens.refreshToken),
  SecureStore.setItemAsync('expires_at', expiresAt.toString()),
]);

// Instead of sequential (slower)
await SecureStore.setItemAsync('access_token', tokens.accessToken);
await SecureStore.setItemAsync('refresh_token', tokens.refreshToken);
await SecureStore.setItemAsync('expires_at', expiresAt.toString());
```

---

## Error Handling Strategy

### Error Categories

```typescript
enum AuthErrorType {
  // User-caused (show friendly message)
  USER_CANCELLED,      // User closed browser

  // Transient (retryable)
  NETWORK_ERROR,       // No internet, timeout

  // Auth-related (re-authentication needed)
  TOKEN_EXPIRED,       // Session expired
  REFRESH_FAILED,      // Can't refresh
  INVALID_CREDENTIALS, // Bad auth

  // Unknown (log and show generic message)
  UNKNOWN_ERROR
}
```

### Error Handling Flow

```
Error Occurs
     ↓
Classify Error
     ↓
┌────┴────┬────────┬─────────┬────────┐
│         │        │         │        │
User    Transient Auth   Config  Unknown
Caused            Related  Error
│         │        │         │        │
↓         ↓        ↓         ↓        ↓
Silent   Retry   Re-auth   Alert   Log &
or Toast         Flow      Dev     Alert
```

### Implementation

```typescript
async function handleAuthError(error: unknown): Promise<void> {
  // 1. Convert to AuthError
  const authError = error instanceof AuthError
    ? error
    : new AuthError(AuthErrorType.UNKNOWN_ERROR, 'An error occurred', error);

  // 2. Log for debugging
  console.error('Auth error:', {
    type: authError.type,
    message: authError.message,
    stack: authError.stack,
  });

  // 3. User-facing handling
  switch (authError.type) {
    case AuthErrorType.USER_CANCELLED:
      // Silent, user knows they cancelled
      break;

    case AuthErrorType.NETWORK_ERROR:
      // Show toast, allow retry
      showToast('Network error. Please check your connection.');
      break;

    case AuthErrorType.TOKEN_EXPIRED:
    case AuthErrorType.REFRESH_FAILED:
      // Clear session, show login
      await clearTokens();
      showAlert('Your session has expired. Please log in again.');
      break;

    case AuthErrorType.INVALID_CREDENTIALS:
      showAlert('Authentication failed. Please try again.');
      break;

    default:
      // Unknown error
      showAlert('An unexpected error occurred. Please try again.');

      // TODO: Send to error reporting service (Sentry, etc.)
      if (errorReportingService) {
        errorReportingService.captureException(authError);
      }
  }
}
```

---

## Future Enhancements

### Potential Additions

1. **Biometric Authentication**
   - Face ID / Touch ID for app unlock
   - Local authentication layer

2. **Offline Support**
   - Cache user data
   - Queue auth actions when offline

3. **Multi-Account Support**
   - Switch between multiple logged-in accounts
   - Account management UI

4. **Session Management**
   - Active sessions list
   - Remote logout capability
   - Device management

5. **Advanced Security**
   - Certificate pinning
   - Jailbreak/root detection
   - App integrity checks

6. **Analytics & Monitoring**
   - Auth success/failure rates
   - Token refresh metrics
   - Error tracking

---

**This architecture provides a solid foundation for enterprise-grade authentication in React Native applications.**
